<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swiss TLM3D Route Planner (Debug Interface)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
        .sidebar { width: 350px; background: white; padding: 20px; box-shadow: 2px 0 5px rgba(0,0,0,0.1); overflow-y: auto; }
        .map-container { flex: 1; }
        #map { height: 100%; width: 100%; }
        .control-panel { padding: 15px; background: #f8f9fa; border-radius: 5px; margin-bottom: 15px; }
        h3, h4 { margin-top: 0; }
        .btn { display: block; width: 100%; background: #007bff; color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; margin-top: 10px; }
        .btn:disabled { background: #6c757d; cursor: not-allowed; }
        .btn-secondary { background: #6c757d; }
        .coordinates { font-family: monospace; font-size: 12px; color: #666; padding: 5px 0; }
        .status { padding: 10px; margin-top: 15px; border-radius: 4px; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .route-info { background: #e9ecef; padding: 15px; border-radius: 4px; margin-top: 15px; display: none; }
        .loading { display: none; text-align: center; padding: 20px; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #007bff; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        .waypoint-item { display: flex; align-items: center; margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6; }
        .waypoint-item .waypoint-number { font-weight: bold; margin-right: 10px; min-width: 60px; }
        .waypoint-item .waypoint-coords { font-family: monospace; font-size: 11px; color: #666; flex: 1; }
        .waypoint-item .waypoint-network { margin: 0 10px; }
        .waypoint-item .waypoint-remove { background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px; }
        .waypoint-item .waypoint-remove:hover { background: #c82333; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="sidebar">
        <h3>üìç Route Planner</h3>
        <p>Use the layer control in the top right of the map to change base maps and toggle overlays.</p>

        <div class="control-panel">
            <h4>Points</h4>
            <div>Start: <span class="coordinates" id="start-coords">Not set</span></div>
            <div>End: <span class="coordinates" id="end-coords">Not set</span></div>
        </div>

        <div class="control-panel">
            <h4>Routing Mode</h4>
            <label><input type="radio" name="routing-mode" value="point-to-point" checked> üìç Point to Point</label><br>
            <label><input type="radio" name="routing-mode" value="multi-point"> üó∫Ô∏è Multi-Point Route</label>
            <small style="color: #666; display: block; margin-top: 5px;">Choose between single route or multi-waypoint routing.</small>
        </div>

        <div class="control-panel">
            <h4>Network</h4>
            <label><input type="radio" name="network-type" value="ski_touring" checked> üéø Ski Touring</label><br>
            <label><input type="radio" name="network-type" value="tlm3d"> üöó TLM3D</label><br>
            <label><input type="radio" name="network-type" value="manual"> üìè Manual (Straight Line)</label>
            <small style="color: #666; display: block; margin-top: 5px;">Choose routing method for each segment.</small>
        </div>

        <div class="control-panel">
            <label for="buffer-slider">Buffer: <span id="buffer-value">5.0</span> km</label>
            <input type="range" id="buffer-slider" min="0.5" max="20" step="0.1" value="5">
        </div>
        
        <button class="btn" id="calculate-btn" onclick="calculateRoute()" disabled>Calculate Route</button>
        <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>

        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div>Calculating...</div>
        </div>
        
        <div id="status-container"></div>
        
        <div id="waypoints-container" class="control-panel" style="display: none;">
            <h4>üó∫Ô∏è Waypoints</h4>
            <div id="waypoints-list">
                <!-- Waypoints will be dynamically added here -->
            </div>
            <button class="btn btn-secondary" onclick="clearAllWaypoints()" style="margin-top: 10px;">Clear All Waypoints</button>
        </div>

        <div id="route-info" class="route-info">
            <h4>üìä Route Info</h4>
            <div><strong>Distance:</strong> <span id="route-length">-</span> km</div>
            <div><strong>Segments Loaded:</strong> <span id="segments-loaded">-</span></div>
            <div><strong>Buffer Used:</strong> <span id="buffer-size">-</span> km</div>
        </div>
        
        <div id="elevation-chart-container" class="route-info" style="display: none;">
            <h4>üèîÔ∏è Elevation Profile</h4>
            <div style="height: 200px; width: 100%; overflow: hidden;">
                <canvas id="elevation-chart" style="max-width: 100%; max-height: 100%;"></canvas>
            </div>
        </div>
    </div>
    
    <div class="map-container">
        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-tilelayer-swiss@2.3.0/dist/Leaflet.TileLayer.Swiss.umd.js"></script>
    
    <script>
        // --- Global State ---
        let map;
        let startMarker = null;
        let endMarker = null;
        let routeLayer = null;
        let startPoint = null;
        let endPoint = null;
        let elevationChart = null;
        
        // --- Multi-Point Routing State ---
        let routingMode = 'point-to-point';
        let waypoints = [];
        let routeLayers = [];

        // --- Map Initialization ---
        function initMap() {
            // --- 1. Define Base Map Layers ---
            const swissWinter = L.tileLayer.swiss({ layer: 'ch.swisstopo.pixelkarte-farbe-winter' });
            const swissColor = L.tileLayer.swiss({ layer: 'ch.swisstopo.pixelkarte-farbe' });
            const swissGrey = L.tileLayer.swiss({ layer: 'ch.swisstopo.pixelkarte-grau' });

            // --- 2. Define Overlay Layers ---
            const slopeAngles = L.tileLayer.swiss({
                layer: 'ch.swisstopo.hangneigung-ueber_30',
                format: 'png',
                opacity: 0.5
            });

            const hikingTrails = L.tileLayer.swiss({
                layer: 'ch.swisstopo.swisstlm3d-wanderwege',
                format: 'png',
                opacity: 0.8
            });
            
            // --- NEW: Add the official ski touring routes overlay ---
            const skiTouringRoutes = L.tileLayer.swiss({
                layer: 'ch.swisstopo-karto.skitouren', // Layer name for official ski routes
                format: 'png',
                opacity: 0.8
            });

            // --- 3. Create the map with a default base layer ---
            map = L.map('map', {
                crs: L.CRS.EPSG2056,
                layers: [swissWinter]
            });
            map.fitSwitzerland();
            map.on('click', onMapClick);

            // --- 4. Create Layer Control Objects ---
            const baseMaps = {
                "Winter Map": swissWinter,
                "Color Map": swissColor,
                "Grey Map": swissGrey
            };

            const overlayMaps = {
                "Slope > 30¬∞": slopeAngles,
                "Marked Trails": hikingTrails,
                "Official Ski Routes": skiTouringRoutes // Add new layer to the control
            };

            // --- 5. Add the Layer Control to the map ---
            L.control.layers(baseMaps, overlayMaps).addTo(map);
            
            // --- 6. Add event listener for buffer slider ---
            document.getElementById('buffer-slider').addEventListener('input', (e) => {
                document.getElementById('buffer-value').textContent = parseFloat(e.target.value).toFixed(1);
            });
        }

        // --- User Interaction ---
        function onMapClick(e) {
            if (routingMode === 'multi-point') {
                // In multi-point mode, add waypoints
                addWaypoint(e.latlng);
            } else {
                // In point-to-point mode, set start/end points
                if (!startPoint) {
                    setPoint('start', e.latlng);
                } else if (!endPoint) {
                    setPoint('end', e.latlng);
                }
            }
        }
        
        function setPoint(type, latlng) {
            const marker = L.marker(latlng, { draggable: true }).addTo(map);
            if (type === 'start') {
                startPoint = latlng;
                startMarker = marker;
                marker.on('dragend', (e) => { startPoint = e.target.getLatLng(); updateCoordsDisplay(); });
            } else {
                endPoint = latlng;
                endMarker = marker;
                marker.on('dragend', (e) => { endPoint = e.target.getLatLng(); updateCoordsDisplay(); });
            }
            updateCoordsDisplay();
            updateCalculateButton();
        }
        
        // --- Backend Communication ---
        async function calculateRoute() {
            if (!startPoint || !endPoint) return;
            showLoading(true);
            clearRoute();
            try {
                const networkType = document.querySelector('input[name="network-type"]:checked').value;
                const bufferDistance = parseFloat(document.getElementById('buffer-slider').value) * 1000;
                const response = await fetch('/calculate_route', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start_coords: [startPoint.lat, startPoint.lng],
                        end_coords: [endPoint.lat, endPoint.lng],
                        buffer_distance: bufferDistance,
                        network_type: networkType
                    })
                });
                const result = await response.json();
                if (result.success && result.route) {
                    displayRoute(result);
                    showStatus('Route calculated successfully!', 'success');
                } else {
                    throw new Error(result.error || 'No route found.');
                }
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        // --- UI Updates & Display ---
        function displayRoute(result) {
            const routeLatLngs = result.route.map(coord => {
                const point = map.options.crs.projection.unproject({ x: coord[0], y: coord[1] });
                return [point.lat, point.lng];
            });
            routeLayer = L.layerGroup().addTo(map);
            L.polyline(routeLatLngs, { color: 'white', weight: 8, opacity: 0.8 }).addTo(routeLayer);
            L.polyline(routeLatLngs, { color: '#ff6600', weight: 5 }).addTo(routeLayer);
            map.fitBounds(L.polyline(routeLatLngs).getBounds(), { padding: [50, 50] });
            document.getElementById('route-info').style.display = 'block';
            document.getElementById('route-length').textContent = (result.path_length / 1000).toFixed(2);
            document.getElementById('segments-loaded').textContent = result.segments_loaded;
            document.getElementById('buffer-size').textContent = (result.buffer_distance / 1000).toFixed(1);
            
            // Display elevation profile if available
            if (result.elevation_profile && result.elevation_profile.length > 0) {
                displayElevationProfile(result.elevation_profile);
            }
        }

        function clearAll() {
            clearRoute();
            if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
            if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
            startPoint = null;
            endPoint = null;
            updateCoordsDisplay();
            updateCalculateButton();
            document.getElementById('route-info').style.display = 'none';
            document.getElementById('elevation-chart-container').style.display = 'none';
            document.getElementById('status-container').innerHTML = '';
            
            // Destroy elevation chart if it exists
            if (elevationChart) {
                elevationChart.destroy();
                elevationChart = null;
            }
            
            // Always clear multi-point routes regardless of current mode
            clearAllWaypoints();
        }

        function clearRoute() {
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
        }

        function updateCoordsDisplay() {
            document.getElementById('start-coords').textContent = startPoint ? `${startPoint.lat.toFixed(5)}, ${startPoint.lng.toFixed(5)}` : 'Not set';
            document.getElementById('end-coords').textContent = endPoint ? `${endPoint.lat.toFixed(5)}, ${endPoint.lng.toFixed(5)}` : 'Not set';
        }

        function updateCalculateButton() {
            document.getElementById('calculate-btn').disabled = !(startPoint && endPoint);
        }
        
        function showStatus(message, type = 'info') {
            document.getElementById('status-container').innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function showLoading(isLoading) {
            document.getElementById('loading').style.display = isLoading ? 'block' : 'none';
        }

        // --- Elevation Profile Chart Functions ---
        function displayElevationProfile(elevationProfile) {
            // Destroy existing chart if it exists
            if (elevationChart) {
                elevationChart.destroy();
                elevationChart = null;
            }
            
            // Show the chart container
            document.getElementById('elevation-chart-container').style.display = 'block';
            
            // Prepare data for Chart.js
            const distances = elevationProfile.map(point => point[0]);
            const elevations = elevationProfile.map(point => point[1]);
            
            // Create the chart with minimal, stable configuration
            const ctx = document.getElementById('elevation-chart').getContext('2d');
            elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: distances.map(d => (d / 1000).toFixed(1) + ' km'),
                    datasets: [{
                        label: 'Elevation',
                        data: elevations,
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        fill: false,
                        tension: 0,
                        pointRadius: 0,
                        pointHoverRadius: 3
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Distance (km)'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            }
                        }
                    }
                }
            });
        }

        // --- Multi-Point Routing Functions ---
        function setupRoutingModeListeners() {
            // Listen for routing mode changes
            document.querySelectorAll('input[name="routing-mode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    routingMode = this.value;
                    if (routingMode === 'multi-point') {
                        document.getElementById('waypoints-container').style.display = 'block';
                        document.getElementById('route-info').style.display = 'none';
                        clearAll(); // Clear existing point-to-point route
                    } else {
                        document.getElementById('waypoints-container').style.display = 'none';
                        document.getElementById('route-info').style.display = 'block';
                        clearAll(); // Clear everything when switching back to point-to-point
                    }
                });
            });
        }

        function addWaypoint(latlng) {
            const waypointNumber = waypoints.length + 1;
            const networkType = document.querySelector('input[name="network-type"]:checked').value;
            
            // Create draggable marker
            const marker = L.marker(latlng, { draggable: true })
                .addTo(map)
                .bindPopup(`Waypoint ${waypointNumber}<br>${latlng.lat.toFixed(5)}, ${latlng.lng.toFixed(5)}`);
            
            // Add drag event listener
            marker.on('dragend', function(e) {
                const waypointIndex = waypoints.findIndex(wp => wp.marker === marker);
                if (waypointIndex !== -1) {
                    waypoints[waypointIndex].latlng = e.target.getLatLng();
                    updateWaypointCoords(waypointIndex);
                    updateMultiPointRoute();
                }
            });
            
            // Create waypoint object
            const waypoint = {
                latlng: latlng,
                marker: marker,
                networkForNextSegment: networkType
            };
            
            waypoints.push(waypoint);
            addWaypointToUI(waypoint, waypointNumber);
            
            // If we have at least 2 waypoints, calculate the route
            if (waypoints.length >= 2) {
                updateMultiPointRoute();
            }
        }

        function addWaypointToUI(waypoint, waypointNumber) {
            const waypointsList = document.getElementById('waypoints-list');
            const waypointDiv = document.createElement('div');
            waypointDiv.className = 'waypoint-item';
            waypointDiv.innerHTML = `
                <span class="waypoint-number">Point ${waypointNumber}</span>
                <span class="waypoint-coords">${waypoint.latlng.lat.toFixed(5)}, ${waypoint.latlng.lng.toFixed(5)}</span>
                <select class="waypoint-network" onchange="updateWaypointNetwork(${waypoints.length - 1}, this.value)">
                    <option value="ski_touring" ${waypoint.networkForNextSegment === 'ski_touring' ? 'selected' : ''}>üéø Ski</option>
                    <option value="tlm3d" ${waypoint.networkForNextSegment === 'tlm3d' ? 'selected' : ''}>üöó TLM3D</option>
                    <option value="manual" ${waypoint.networkForNextSegment === 'manual' ? 'selected' : ''}>üìè Manual</option>
                </select>
                <button class="waypoint-remove" onclick="removeWaypoint(${waypoints.length - 1})">√ó</button>
            `;
            waypointsList.appendChild(waypointDiv);
        }

        function updateWaypointCoords(index) {
            const waypoint = waypoints[index];
            const waypointDiv = document.querySelectorAll('.waypoint-item')[index];
            if (waypointDiv) {
                waypointDiv.querySelector('.waypoint-coords').textContent = 
                    `${waypoint.latlng.lat.toFixed(5)}, ${waypoint.latlng.lng.toFixed(5)}`;
            }
        }

        function updateWaypointNetwork(index, networkType) {
            waypoints[index].networkForNextSegment = networkType;
            updateMultiPointRoute();
        }

        function removeWaypoint(index) {
            // Remove marker from map
            if (waypoints[index].marker) {
                map.removeLayer(waypoints[index].marker);
            }
            
            // Remove from waypoints array
            waypoints.splice(index, 1);
            
            // Rebuild UI and recalculate route
            rebuildWaypointsUI();
            if (waypoints.length >= 2) {
                updateMultiPointRoute();
            } else {
                clearAllRouteLayers();
            }
        }

        function rebuildWaypointsUI() {
            const waypointsList = document.getElementById('waypoints-list');
            waypointsList.innerHTML = '';
            
            waypoints.forEach((waypoint, index) => {
                addWaypointToUI(waypoint, index + 1);
            });
        }

        function clearAllWaypoints() {
            // Remove all markers from map
            waypoints.forEach(waypoint => {
                if (waypoint.marker) {
                    map.removeLayer(waypoint.marker);
                }
            });
            
            // Clear arrays and UI
            waypoints = [];
            routeLayers = [];
            document.getElementById('waypoints-list').innerHTML = '';
            clearAllRouteLayers();
            
            // Clear elevation profile
            if (elevationChart) {
                elevationChart.destroy();
                elevationChart = null;
            }
            document.getElementById('elevation-chart-container').style.display = 'none';
            window.completeElevationProfile = [];
        }

        function clearAllRouteLayers() {
            routeLayers.forEach(layer => {
                if (layer) {
                    map.removeLayer(layer);
                }
            });
            routeLayers = [];
        }

        async function updateMultiPointRoute() {
            clearAllRouteLayers();
            
            if (waypoints.length < 2) return;
            
            // Reset elevation profile for new route
            window.completeElevationProfile = [];
            
            let totalDistance = 0;
            let totalSegments = 0;
            
            for (let i = 0; i < waypoints.length - 1; i++) {
                const currentWaypoint = waypoints[i];
                const nextWaypoint = waypoints[i + 1];
                const networkType = currentWaypoint.networkForNextSegment;
                
                if (networkType === 'manual') {
                    // Draw straight line with same thick orange style
                    const whiteOutline = L.polyline([currentWaypoint.latlng, nextWaypoint.latlng], {
                        color: 'white',
                        weight: 8,
                        opacity: 0.8
                    }).addTo(map);
                    const orangeCenter = L.polyline([currentWaypoint.latlng, nextWaypoint.latlng], {
                        color: '#ff6600',
                        weight: 5
                    }).addTo(map);
                    routeLayers.push(whiteOutline, orangeCenter);
                    
                    // Calculate distance
                    const distance = currentWaypoint.latlng.distanceTo(nextWaypoint.latlng) / 1000;
                    totalDistance += distance;
                    totalSegments++;
                    
                    // For manual segments, create a simple elevation profile (flat line)
                    if (!window.completeElevationProfile) {
                        window.completeElevationProfile = [];
                    }
                    const segmentStartDistance = window.completeElevationProfile.length > 0 ? 
                        window.completeElevationProfile[window.completeElevationProfile.length - 1][0] : 0;
                    
                    // Add start and end points with estimated elevation (you could fetch this separately if needed)
                    window.completeElevationProfile.push([segmentStartDistance, 1000]); // Start elevation
                    window.completeElevationProfile.push([segmentStartDistance + distance * 1000, 1000]); // End elevation
                } else {
                    // Use backend routing
                    try {
                        const response = await fetch('/calculate_route', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                start_coords: [currentWaypoint.latlng.lat, currentWaypoint.latlng.lng],
                                end_coords: [nextWaypoint.latlng.lat, nextWaypoint.latlng.lng],
                                network_type: networkType,
                                buffer_distance: parseFloat(document.getElementById('buffer-slider').value) * 1000
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && result.route) {
                                // Convert LV95 coordinates to WGS84 for display
                                const routeLatLngs = result.route.map(coord => {
                                    const point = map.options.crs.projection.unproject({ x: coord[0], y: coord[1] });
                                    return [point.lat, point.lng];
                                });
                                
                                // Use the same thick orange style as single routes
                                const whiteOutline = L.polyline(routeLatLngs, {
                                    color: 'white',
                                    weight: 8,
                                    opacity: 0.8
                                }).addTo(map);
                                const orangeCenter = L.polyline(routeLatLngs, {
                                    color: '#ff6600',
                                    weight: 5
                                }).addTo(map);
                                routeLayers.push(whiteOutline, orangeCenter);
                                
                                totalDistance += result.path_length / 1000;
                                totalSegments += result.segments_loaded;
                                
                                // Store elevation data for the complete route
                                if (result.elevation_profile && result.elevation_profile.length > 0) {
                                    if (!window.completeElevationProfile) {
                                        window.completeElevationProfile = [];
                                    }
                                    // Add segment elevation data with cumulative distance
                                    const segmentStartDistance = window.completeElevationProfile.length > 0 ? 
                                        window.completeElevationProfile[window.completeElevationProfile.length - 1][0] : 0;
                                    
                                    result.elevation_profile.forEach(point => {
                                        window.completeElevationProfile.push([
                                            segmentStartDistance + point[0],
                                            point[1]
                                        ]);
                                    });
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Error calculating route segment:', error);
                    }
                }
            }
            
            // Update route info
            document.getElementById('route-length').textContent = totalDistance.toFixed(2);
            document.getElementById('segments-loaded').textContent = totalSegments;
            document.getElementById('buffer-size').textContent = (parseFloat(document.getElementById('buffer-slider').value)).toFixed(1);
            
            // Display elevation profile for the complete multi-point route
            if (window.completeElevationProfile && window.completeElevationProfile.length > 0) {
                displayElevationProfile(window.completeElevationProfile);
                console.log(`Complete route elevation profile: ${window.completeElevationProfile.length} points`);
            }
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            setupRoutingModeListeners();
        });
    </script>
</body>
</html>