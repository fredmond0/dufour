<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swiss TLM3D Route Planner</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 350px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        .control-panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-panel h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }
        
        .point-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        
        .point-info.start {
            border-left-color: #28a745;
        }
        
        .point-info.end {
            border-left-color: #dc3545;
        }
        
        .coordinates {
            font-family: monospace;
            font-size: 12px;
            color: #666;
        }
        
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .btn.success {
            background: #28a745;
        }
        
        .btn.danger {
            background: #dc3545;
        }
        
        .btn.secondary {
            background: #6c757d;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .buffer-control {
            margin: 15px 0;
        }
        
        .buffer-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .buffer-control input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .buffer-value {
            text-align: center;
            font-weight: bold;
            color: #007bff;
        }
        
        .route-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        .route-info h4 {
            margin-top: 0;
            color: #495057;
        }
        
        .routing-mode {
            margin: 15px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        
        .routing-mode label {
            margin-right: 15px;
            cursor: pointer;
        }
        
        .bounding-box-control {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        
        .bounding-box-control label {
            cursor: pointer;
        }
        
        .help-tip {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 10px 0;
            font-size: 13px;
            color: #1565c0;
        }
        
        .point-to-point-controls {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        
        .multi-point-controls {
            margin: 15px 0;
            padding: 15px;
            background: #fff3cd;
            border-radius: 6px;
            border: 1px solid #ffeaa7;
        }
        
        .waypoints-list h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #856404;
        }
        
        .waypoint-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            border: 1px solid #ffeaa7;
        }
        
        .waypoint-number {
            background: #ffc107;
            color: #000;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }
        
        .waypoint-coords {
            flex: 1;
            margin: 0 10px;
            font-size: 12px;
            color: #666;
        }
        
        .waypoint-remove {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .no-waypoints {
            text-align: center;
            color: #856404;
            font-style: italic;
            margin: 20px 0;
        }
        
        .route-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        
        .elevation-profile {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 4px;
        }
        
        .elevation-profile h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #495057;
        }
        
        #elevation-canvas {
            width: 100%;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }
        
        .elevation-legend {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
        
        .waypoint-marker {
            background: #ffc107;
            border: 2px solid #fff;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-weight: bold;
            color: #000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .profile-marker {
            background: #dc3545;
            border: 2px solid #fff;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 1000;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="control-panel">
                <h3>üöó Swiss TLM3D Route Planner</h3>
                <p>Click on the map to set start and end points, then calculate your route.</p>
                <p><small>üó∫Ô∏è Use the layer control (top right) to switch between map styles</small></p>
                

                
                <div class="routing-mode">
                    <label>
                        <input type="radio" name="routing-mode" value="single" checked> Point to Point
                    </label>
                    <label>
                        <input type="radio" name="routing-mode" value="multi"> Multi-Point Route
                    </label>
                </div>
                
                <div class="help-tip">
                    üí° <strong>Tip:</strong> Click anywhere along a road - you don't need to click exactly at junctions!
                </div>
                
                <!-- Point to Point Controls (only visible in single mode) -->
                <div id="point-to-point-controls" class="point-to-point-controls">
                    <div class="point-inputs">
                        <div class="point-input">
                            <label>Start Point:</label>
                            <div class="coordinates" id="start-coords">Not set</div>
                            <button class="btn btn-secondary" onclick="clearPoint('start')">Clear</button>
                        </div>
                        
                        <div class="point-input">
                            <label>End Point:</label>
                            <div class="coordinates" id="end-coords">Not set</div>
                            <button class="btn btn-secondary" onclick="clearPoint('end')">Clear</button>
                        </div>
                        
                        <button class="btn" id="calculate-btn" onclick="calculateRoute()" disabled>
                            üßÆ Calculate Route
                        </button>
                    </div>
                </div>
                
                <!-- Multi-Point Controls (only visible in multi mode) -->
                <div id="multi-point-controls" class="multi-point-controls" style="display: none;">
                    <div class="waypoints-list">
                        <h4>üó∫Ô∏è Waypoints</h4>
                        <div id="waypoints-container">
                            <p class="no-waypoints">Click on the map to add waypoints</p>
                        </div>
                    </div>
                    
                    <button class="btn btn-secondary" onclick="clearAll()">
                        üóëÔ∏è Clear All Waypoints
                    </button>
                </div>
                
                <div class="buffer-control">
                    <label for="buffer-slider">Buffer Distance: <span id="buffer-value">2.0</span> km</label>
                    <input type="range" id="buffer-slider" min="0.5" max="20" step="0.1" value="2">
                    <div class="buffer-value">Adjust clipping area size</div>
                </div>
                
                <div class="bounding-box-control">
                    <label>
                        <input type="checkbox" id="show-bbox"> Show Bounding Box
                    </label>
                </div>
                
                <button class="btn btn-secondary" onclick="clearRoute()">
                    üóëÔ∏è Clear Route
                </button>
                
                <button class="btn btn-secondary" id="export-gpx-btn" onclick="exportToGPX()" style="display: none;">
                    üìç Export GPX
                </button>
                

            </div>
            
            <div id="status-container"></div>
            
            <div id="route-info" class="route-info" style="display: none;">
                <h4>üìä Route Information</h4>
                <div class="route-stats">
                    <div class="stat">
                        <div class="stat-value" id="route-length">-</div>
                        <div class="stat-label">Distance (km)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="route-nodes">-</div>
                        <div class="stat-label">Waypoints</div>
                    </div>
                </div>
                <div class="route-stats">
                    <div class="stat">
                        <div class="stat-value" id="buffer-size">-</div>
                        <div class="stat-label">Buffer (km)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="roads-loaded">-</div>
                        <div class="stat-label">Roads Loaded</div>
                    </div>
                </div>
                <div class="route-stats">
                    <div class="stat">
                        <div class="stat-value" id="elevation-gain">-</div>
                        <div class="stat-label">Elevation Gain (m)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="elevation-loss">-</div>
                        <div class="stat-label">Elevation Loss (m)</div>
                    </div>
                </div>
            </div>
            
            <div id="elevation-profile" class="elevation-profile" style="display: none;">
                <h4>üèîÔ∏è Elevation Profile</h4>
                <canvas id="elevation-canvas" width="400" height="200"></canvas>
                <div class="elevation-legend">
                    <span>Distance (km) ‚Üí</span>
                    <span>‚Üë Elevation (m)</span>
                </div>
            </div>
            
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <div>Calculating route...</div>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet.TileLayer.Swiss for official Swisstopo maps -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-tilelayer-swiss@2.3.0/dist/Leaflet.TileLayer.Swiss.umd.js"></script>
    
    <script>
        // Global variables
        let map;
        let startMarker = null;
        let endMarker = null;
        let routeLine = null;
        let clippedAreaPolygon = null;
        let startPoint = null;
        let endPoint = null;
        let waypoints = []; // Array of waypoints for multi-point routing
        let waypointMarkers = []; // Array of waypoint markers on map
        let bufferDistance = 2.0; // km - reduced default for closer routing
        let showBoundingBox = false; // Default: bounding box hidden
        
        // Initialize the map
        function initMap() {
            // Create map with Swiss LV95 projection
            map = L.map('map', {
                crs: L.CRS.EPSG2056
            });
            
            // Add Swiss topographic maps
            const swissTopo = L.tileLayer.swiss();
            const swissGrey = L.tileLayer.swiss({ layer: 'ch.swisstopo.pixelkarte-grau' });
            const swissOrtho = L.tileLayer.swiss({ layer: 'ch.swisstopo.swissimage' });
            
            // Add layer control
            const baseMaps = {
                "Swisstopo Color": swissTopo,
                "Swisstopo Grey": swissGrey,
                "Swisstopo Ortho": swissOrtho
            };
            
            L.control.layers(baseMaps).addTo(map);
            swissTopo.addTo(map);
            
            // Center on Switzerland
            map.fitSwitzerland();
            
            // Add click event and initialize UI
            map.on('click', onMapClick);
            initUI();
        }
        
        // Initialize UI components
        function initUI() {
            document.getElementById('buffer-slider').addEventListener('input', function(e) {
                bufferDistance = parseFloat(e.target.value);
                document.getElementById('buffer-value').textContent = bufferDistance.toFixed(1);
                if (startPoint && endPoint) {
                    updateClippedArea();
                }
            });
        }
        
        // Handle map clicks - use Swiss projection coordinates directly
        function onMapClick(e) {
            // Use Leaflet's built-in coordinate transformation properly
            console.log(`=== Map Click Debug ===`);
            console.log(`Raw latlng:`, e.latlng);
            console.log(`Map CRS:`, map.options.crs);
            
            // Store the original click coordinates for marker placement
            const originalLatLng = { lat: e.latlng.lat, lng: e.latlng.lng };
            
            // Try to get the CRS coordinates directly
            let swissCoords;
            
            try {
                // Method 1: Try to get the CRS coordinates directly
                const crsPoint = map.options.crs.latLngToPoint(e.latlng, map.getZoom());
                console.log(`CRS point:`, crsPoint);
                
                // Method 2: Try to transform to the CRS projection
                const transformed = map.options.crs.projection.project(e.latlng);
                console.log(`Transformed to projection:`, transformed);
                
                // Check if we got valid LV95 coordinates
                if (transformed && transformed.x > 2000000 && transformed.y > 500000) {
                    swissCoords = { x: Math.round(transformed.x), y: Math.round(transformed.y) };
                    console.log(`‚úÖ Got LV95 coordinates via projection: (${swissCoords.x}, ${swissCoords.y})`);
                } else {
                    throw new Error('Projection returned invalid coordinates');
                }
            } catch (error) {
                console.log(`‚ö†Ô∏è Leaflet projection failed:`, error.message);
                console.log(`üîÑ Falling back to manual conversion`);
                swissCoords = convertLatLngToSwiss(e.latlng.lat, e.latlng.lng);
                console.log(`Manual conversion to LV95: (${swissCoords.x}, ${swissCoords.y})`);
            }
            
            // Check current routing mode
            const isMultiPoint = document.querySelector('input[name="routing-mode"][value="multi"]').checked;
            
            if (isMultiPoint) {
                // Multi-point routing mode
                handleMultiPointClick(swissCoords, originalLatLng);
            } else {
                // Single route mode (original functionality)
                handleSingleRouteClick(swissCoords, originalLatLng);
            }
        }
        
        // Handle clicks in single route mode
        function handleSingleRouteClick(swissCoords, originalLatLng) {
            // Check if we're clicking too close to existing points
            if (startPoint && isTooClose(swissCoords.x, swissCoords.y, startPoint.swiss.x, startPoint.swiss.y)) {
                showStatus('Click further away from the start point', 'warning');
                return;
            }
            
            if (endPoint && isTooClose(swissCoords.x, swissCoords.y, endPoint.swiss.x, endPoint.swiss.y)) {
                showStatus('Click further away from the end point', 'warning');
                return;
            }
            
            // Set the point
            if (!startPoint) {
                setStartPoint(swissCoords, originalLatLng);
                showStatus('Start point set! Now click for end point', 'success');
            } else if (!endPoint) {
                setEndPoint(swissCoords, originalLatLng);
                showStatus('End point set! Click "Calculate Route" to find the path', 'success');
            } else {
                // Both points set, ask user what to do
                if (confirm('Both start and end points are set. Click "OK" to set a new start point, or "Cancel" to set a new end point.')) {
                    clearPoint('start');
                    setStartPoint(swissCoords, originalLatLng);
                } else {
                    clearPoint('end');
                    setEndPoint(swissCoords, originalLatLng);
                }
            }
        }
        
        // Handle clicks in multi-point mode
        function handleMultiPointClick(swissCoords, originalLatLng) {
            // Check if we're clicking too close to existing waypoints
            for (let waypoint of waypoints) {
                if (isTooClose(swissCoords.x, swissCoords.y, waypoint.swiss.x, waypoint.swiss.y)) {
                    showStatus('Click further away from existing waypoints', 'warning');
                    return;
                }
            }
            
            // Add new waypoint
            const waypoint = {
                swiss: swissCoords,
                lat: originalLatLng.lat,
                lng: originalLatLng.lng,
                marker: null
            };
            
            waypoints.push(waypoint);
            
            // Create draggable marker for this waypoint
            const marker = L.marker([originalLatLng.lat, originalLatLng.lng], {
                icon: L.divIcon({
                    className: 'waypoint-marker',
                    html: `${waypoints.length}`,
                    iconSize: [24, 24]
                }),
                draggable: true
            }).addTo(map);
            
            // Store marker reference
            waypoint.marker = marker;
            waypointMarkers.push(marker);
            
            // Add drag event handlers
            marker.on('dragend', function(e) {
                const newLatLng = e.target.getLatLng();
                const newSwissCoords = map.options.crs.projection.project(newLatLng);
                
                // Update waypoint coordinates
                waypoint.lat = newLatLng.lat;
                waypoint.lng = newLatLng.lng;
                waypoint.swiss = { x: Math.round(newSwissCoords.x), y: Math.round(newSwissCoords.y) };
                
                // Update waypoints display
                updateWaypointsDisplay();
                
                // Recalculate route if we have at least 2 waypoints
                if (waypoints.length >= 2) {
                    calculateMultiPointRoute();
                }
                
                showStatus(`Waypoint ${waypoints.indexOf(waypoint) + 1} moved. Route updated!`, 'success');
            });
            
            // Update waypoints display
            updateWaypointsDisplay();
            
            // If we have at least 2 waypoints, calculate and display route
            if (waypoints.length >= 2) {
                calculateMultiPointRoute();
            }
            
            showStatus(`Waypoint ${waypoints.length} added! Route will update automatically.`, 'success');
        }
        
        // Simple coordinate conversion - much cleaner than complex math
        function convertLatLngToSwiss(lat, lng) {
            // This is still a simplified approach, but much cleaner
            // In a production system, you'd use a proper coordinate transformation library
            
            // Switzerland bounds and LV95 ranges
            const latMin = 45.8, latMax = 47.8;
            const lngMin = 5.9, lngMax = 10.5;
            const xMin = 2400000, xMax = 2900000;
            const yMin = 1000000, yMax = 1300000;
            
            // Clamp coordinates to Switzerland bounds
            const clampedLat = Math.max(latMin, Math.min(latMax, lat));
            const clampedLng = Math.max(lngMin, Math.min(lngMax, lng));
            
            // Linear interpolation
            const latRatio = (clampedLat - latMin) / (latMax - latMin);
            const lngRatio = (clampedLng - lngMin) / (lngMax - lngMin);
            
            const x = xMin + lngRatio * (xMax - xMin);
            const y = yMin + latRatio * (yMax - yMin);
            
            return { x: Math.round(x), y: Math.round(y) };
        }
        

        
        // Check if two points are too close (less than 100m = 0.1km)
        function isTooClose(x1, y1, x2, y2) {
            const distance = Math.sqrt((x1 - x2)**2 + (y1 - y2)**2);
            return distance < 100; // Reduced from 1000m to 100m for much closer points
        }
        
        // Set start point
        function setStartPoint(swissCoords, originalLatLng) {
            startPoint = { swiss: swissCoords };
            
            // Remove existing start marker
            if (startMarker) {
                map.removeLayer(startMarker);
            }
            
            // Use the original click coordinates for marker placement (no conversion needed!)
            startMarker = L.marker([originalLatLng.lat, originalLatLng.lng], {
                icon: L.divIcon({
                    className: 'start-marker',
                    html: 'üü¢',
                    iconSize: [20, 20]
                })
            }).addTo(map);
            
            // Update UI
            document.getElementById('start-coords').textContent = 
                `LV95: (${swissCoords.x.toFixed(0)}, ${swissCoords.y.toFixed(0)})`;
            
            updateCalculateButton();
            updateClippedArea();
        }
        
        // Set end point
        function setEndPoint(swissCoords, originalLatLng) {
            endPoint = { swiss: swissCoords };
            
            // Remove existing end marker
            if (endMarker) {
                map.removeLayer(endMarker);
            }
            
            // Use the original click coordinates for marker placement (no conversion needed!)
            endMarker = L.marker([originalLatLng.lat, originalLatLng.lng], {
                icon: L.divIcon({
                    className: 'end-marker',
                    html: 'üî¥',
                    iconSize: [20, 20]
                })
            }).addTo(map);
            
            // Update UI
            document.getElementById('end-coords').textContent = 
                `LV95: (${swissCoords.x.toFixed(0)}, ${swissCoords.y.toFixed(0)})`;
            
            updateCalculateButton();
            updateClippedArea();
        }
        
        // Clear a specific point
        function clearPoint(type) {
            if (type === 'start') {
                if (startMarker) {
                    map.removeLayer(startMarker);
                    startMarker = null;
                }
                startPoint = null;
                document.getElementById('start-coords').textContent = 'Not set';
            } else if (type === 'end') {
                if (endMarker) {
                    map.removeLayer(endMarker);
                    endMarker = null;
                }
                endPoint = null;
                document.getElementById('end-coords').textContent = 'Not set';
            }
            
            updateCalculateButton();
            updateClippedArea();
        }
        
        // Update calculate button state
        function updateCalculateButton() {
            const btn = document.getElementById('calculate-btn');
            if (startPoint && endPoint) {
                btn.disabled = false;
                btn.textContent = 'üßÆ Calculate Route';
            } else {
                btn.disabled = true;
                btn.textContent = 'üßÆ Calculate Route (Set both points)';
            }
        }
        
        // Update clipped area visualization
        function updateClippedArea() {
            if (!startPoint || !endPoint) {
                if (clippedAreaPolygon) {
                    map.removeLayer(clippedAreaPolygon);
                    clippedAreaPolygon = null;
                }
                return;
            }
            
            // Check if bounding box should be shown
            if (!showBoundingBox) {
                if (clippedAreaPolygon) {
                    map.removeLayer(clippedAreaPolygon);
                    clippedAreaPolygon = null;
                }
                return;
            }
            
            // Remove existing clipped area
            if (clippedAreaPolygon) {
                map.removeLayer(clippedAreaPolygon);
            }
            
            // Calculate bounding box with buffer in LV95 coordinates
            const bufferMeters = bufferDistance * 1000;
            
            const minX = Math.min(startPoint.swiss.x, endPoint.swiss.x) - bufferMeters;
            const maxX = Math.max(startPoint.swiss.x, endPoint.swiss.x) + bufferMeters;
            const minY = Math.min(startPoint.swiss.y, endPoint.swiss.y) - bufferMeters;
            const maxY = Math.max(startPoint.swiss.y, endPoint.swiss.y) + bufferMeters;
            
            // Convert LV95 bounds to lat/lng using proper CRS transformation
            const bounds = [
                map.options.crs.projection.unproject({ x: minX, y: minY }), // bottom-left
                map.options.crs.projection.unproject({ x: maxX, y: minY }), // bottom-right
                map.options.crs.projection.unproject({ x: maxX, y: maxY }), // top-right
                map.options.crs.projection.unproject({ x: minX, y: maxY })  // top-left
            ];
            
            // Extract lat/lng from the projected points
            const boundsLatLng = bounds.map(point => [point.lat, point.lng]);
            
            clippedAreaPolygon = L.polygon(boundsLatLng, {
                color: '#007bff',
                weight: 3,           // Increased from 2 to 3 for better visibility
                fillColor: '#007bff',
                fillOpacity: 0.15,   // Increased from 0.1 to 0.15 for better visibility
                smoothFactor: 0,     // Set to 0 for maximum precision
                lineCap: 'round',    // Rounded line ends
                lineJoin: 'round',   // Rounded line joins
                renderer: L.canvas() // Use canvas renderer for better quality
            }).addTo(map);
            
            // Fit map to show the clipped area
            map.fitBounds(boundsLatLng, { padding: [20, 20] });
        }
        
        // Calculate route (single route mode)
        async function calculateRoute() {
            if (!startPoint || !endPoint) {
                showStatus('Please set both start and end points first.', 'warning');
                return;
            }
            
            showStatus('Calculating route...', 'info');
            showLoading(true);
            
            try {
                // Prepare data for backend
                const routeData = {
                    start_coords: [startPoint.swiss.x, startPoint.swiss.y],
                    end_coords: [endPoint.swiss.x, endPoint.swiss.y],
                    buffer_distance: bufferDistance * 1000 // Convert to meters
                };
                
                console.log('Sending route data to backend:', routeData);
                console.log('Start point object:', startPoint);
                console.log('End point object:', endPoint);
                
                // Call Python backend (you'll need to set up a simple web server)
                const response = await fetch('/calculate_route', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(routeData)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    displayRoute(result.route, result.path_length, result.roads_loaded);
                    showStatus('Route calculated successfully!', 'success');
                } else {
                    throw new Error(result.error || 'Route calculation failed');
                }
                
            } catch (error) {
                console.error('Error calculating route:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Calculate multi-point route
        async function calculateMultiPointRoute() {
            if (waypoints.length < 2) {
                return; // Need at least 2 waypoints
            }
            
            showStatus('Calculating multi-point route...', 'info');
            showLoading(true);
            
            try {
                // For now, we'll calculate route between consecutive waypoints
                // In the future, this could be optimized to calculate the entire route at once
                let totalRoute = [];
                let totalLength = 0;
                let totalRoadsLoaded = 0;
                
                // Calculate route between each pair of consecutive waypoints
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const start = waypoints[i];
                    const end = waypoints[i + 1];
                    
                    const routeData = {
                        start_coords: [start.swiss.x, start.swiss.y],
                        end_coords: [end.swiss.x, end.swiss.y],
                        buffer_distance: bufferDistance * 1000
                    };
                    
                    const response = await fetch('/calculate_route', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(routeData)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Combine route segments
                        if (totalRoute.length > 0) {
                            // Remove first point of this segment to avoid duplication
                            totalRoute = totalRoute.concat(result.route.slice(1));
                        } else {
                            totalRoute = result.route;
                        }
                        totalLength += result.path_length;
                        totalRoadsLoaded += result.roads_loaded;
                    } else {
                        throw new Error(result.error || 'Route calculation failed');
                    }
                }
                
                // Display the combined route
                displayRoute(totalRoute, totalLength, totalRoadsLoaded);
                showStatus('Multi-point route calculated successfully!', 'success');
                
            } catch (error) {
                console.error('Error calculating multi-point route:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Display the calculated route
        function displayRoute(route, pathLength, roadsLoaded) {
            // Remove existing route
            if (routeLine) {
                map.removeLayer(routeLine);
            }
            
            // Convert LV95 coordinates back to lat/lng using proper CRS transformation
            const routeLatLng = route.map(coord => {
                const projected = map.options.crs.projection.unproject({ x: coord[0], y: coord[1] });
                return [projected.lat, projected.lng];
            });
            
            console.log('Displaying route with coordinates:', routeLatLng);
            
            // Draw route line with maximum quality and precision
            routeLine = L.polyline(routeLatLng, {
                color: '#28a745',
                weight: 8,           // Increased from 6 to 8 for better visibility
                opacity: 0.9,        // Increased from 0.8 to 0.9 for better contrast
                smoothFactor: 0,     // Set to 0 for maximum precision - draw through every single waypoint
                lineCap: 'round',    // Rounded line ends
                lineJoin: 'round',   // Rounded line joins
                renderer: L.canvas() // Use canvas renderer for better quality with many points
            }).addTo(map);
            
            // Fit map to show the entire route
            map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
            
            // Update route info
            document.getElementById('route-info').style.display = 'block';
            document.getElementById('route-length').textContent = (pathLength / 1000).toFixed(2);
            document.getElementById('route-nodes').textContent = route.length;
            document.getElementById('buffer-size').textContent = bufferDistance.toFixed(1);
            document.getElementById('roads-loaded').textContent = roadsLoaded;
            
            // Update route display controls
            updateRouteDisplay();
            
            // Generate and display elevation profile
            const profileData = generateElevationProfile(routeLatLng);
            drawElevationProfile(profileData);
        }
        
        // Clear route
        function clearRoute() {
            if (routeLine) {
                map.removeLayer(routeLine);
                routeLine = null;
            }
            document.getElementById('route-info').style.display = 'none';
            document.getElementById('elevation-profile').style.display = 'none';
            updateRouteDisplay(); // Hide GPX export button
        }
        
        // Clear all
        function clearAll() {
            clearPoint('start');
            clearPoint('end');
            clearRoute();
            
            // Clear waypoints
            waypoints.forEach(waypoint => {
                if (waypoint.marker) {
                    map.removeLayer(waypoint.marker);
                }
            });
            waypoints = [];
            waypointMarkers = [];
            
            if (clippedAreaPolygon) {
                map.removeLayer(clippedAreaPolygon);
                clippedAreaPolygon = null;
            }
            
            // Update UI
            updateStartEndDisplay();
            updateWaypointsDisplay();
            
            showStatus('All data cleared.', 'info');
        }
        
        // Show status message
        function showStatus(message, type = 'info') {
            const container = document.getElementById('status-container');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            
            container.appendChild(statusDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }
        
        // Show/hide loading spinner
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        

        

        
        // Handle single route mode

        
        // Handle routing mode changes
        function initRoutingModeControls() {
            const singleMode = document.querySelector('input[name="routing-mode"][value="single"]');
            const multiMode = document.querySelector('input[name="routing-mode"][value="multi"]');
            
            singleMode.addEventListener('change', function() {
                if (this.checked) {
                    handleSingleRouteMode();
                }
            });
            
            multiMode.addEventListener('change', function() {
                if (this.checked) {
                    handleMultiPointMode();
                }
            });
        }
        
        // Handle single route mode
        function handleSingleRouteMode() {
            document.getElementById('point-to-point-controls').style.display = 'block';
            document.getElementById('multi-point-controls').style.display = 'none';
            
            // Clear multi-point data
            waypoints = [];
            clearRoute();
            updateWaypointsDisplay();
        }
        
        // Handle multi-point routing mode
        function handleMultiPointMode() {
            document.getElementById('point-to-point-controls').style.display = 'none';
            document.getElementById('multi-point-controls').style.display = 'block';
            
            // Clear single route data
            startPoint = null;
            endPoint = null;
            clearRoute();
            updateStartEndDisplay();
        }
        
        // Update waypoints display
        function updateWaypointsDisplay() {
            const container = document.getElementById('waypoints-container');
            
            if (waypoints.length === 0) {
                container.innerHTML = '<p class="no-waypoints">Click on the map to add waypoints</p>';
                return;
            }
            
            container.innerHTML = '';
            waypoints.forEach((waypoint, index) => {
                const waypointItem = document.createElement('div');
                waypointItem.className = 'waypoint-item';
                waypointItem.innerHTML = `
                    <div class="waypoint-number">${index + 1}</div>
                    <div class="waypoint-coords">${waypoint.lat.toFixed(6)}, ${waypoint.lng.toFixed(6)}</div>
                    <button class="waypoint-remove" onclick="removeWaypoint(${index})">√ó</button>
                `;
                container.appendChild(waypointItem);
            });
        }
        
        // Remove waypoint
        function removeWaypoint(index) {
            waypoints.splice(index, 1);
            updateWaypointsDisplay();
            
            // Remove marker from map
            if (waypointMarkers[index]) {
                map.removeLayer(waypointMarkers[index]);
                waypointMarkers.splice(index, 1);
            }
            
            // Recalculate route if we have enough waypoints
            if (waypoints.length >= 2) {
                calculateMultiPointRoute();
            } else {
                clearRoute();
            }
        }
        
        // Update start/end point display
        function updateStartEndDisplay() {
            if (startPoint) {
                document.getElementById('start-coords').textContent = 
                    `LV95: (${startPoint.swiss.x.toFixed(0)}, ${startPoint.swiss.y.toFixed(0)})`;
            } else {
                document.getElementById('start-coords').textContent = 'Not set';
            }
            
            if (endPoint) {
                document.getElementById('end-coords').textContent = 
                    `LV95: (${endPoint.swiss.x.toFixed(0)}, ${endPoint.swiss.y.toFixed(0)})`;
            } else {
                document.getElementById('end-coords').textContent = 'Not set';
            }
            
            updateCalculateButton();
        }
        
        // Handle bounding box visibility
        function initBoundingBoxControl() {
            const showBboxCheckbox = document.getElementById('show-bbox');
            
            showBboxCheckbox.addEventListener('change', function() {
                showBoundingBox = this.checked;
                if (showBoundingBox) {
                    if (startPoint && endPoint) {
                        updateClippedArea();
                    }
                } else {
                    if (clippedAreaPolygon) {
                        map.removeLayer(clippedAreaPolygon);
                        clippedAreaPolygon = null;
                    }
                }
            });
        }
        
        // Export route to GPX format
        function exportToGPX() {
            if (!routeLine) {
                showStatus('No route to export!', 'warning');
                return;
            }
            
            try {
                // Get route coordinates
                const routeCoords = routeLine.getLatLngs();
                
                // Create GPX content
                const gpxContent = generateGPX(routeCoords);
                
                // Create and download file
                const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `swiss_route_${new Date().toISOString().slice(0, 10)}.gpx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('GPX file exported successfully!', 'success');
            } catch (error) {
                console.error('Error exporting GPX:', error);
                showStatus('Error exporting GPX file', 'error');
            }
        }
        
        // Generate GPX content
        function generateGPX(routeCoords) {
            const now = new Date().toISOString();
            const routeName = `Swiss TLM3D Route - ${new Date().toLocaleDateString()}`;
            
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Swiss TLM3D Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${routeName}</name>
    <desc>Route planned with Swiss TLM3D Route Planner</desc>
    <time>${now}</time>
    <bounds minlat="${Math.min(...routeCoords.map(c => c.lat))}" minlon="${Math.min(...routeCoords.map(c => c.lng))}" maxlat="${Math.max(...routeCoords.map(c => c.lat))}" maxlon="${Math.max(...routeCoords.map(c => c.lng))}"/>
  </metadata>
  <trk>
    <name>${routeName}</name>
    <trkseg>`;
            
            // Add track points
            routeCoords.forEach((coord, index) => {
                const time = new Date(Date.now() + index * 60000).toISOString(); // Estimate time
                gpx += `
      <trkpt lat="${coord.lat}" lon="${coord.lng}">
        <time>${time}</time>
      </trkpt>`;
            });
            
            gpx += `
    </trkseg>
  </trk>
</gpx>`;
            
            return gpx;
        }
        
        // Update route display to show GPX export button
        function updateRouteDisplay() {
            const exportGpxBtn = document.getElementById('export-gpx-btn');
            if (routeLine) {
                exportGpxBtn.style.display = 'inline-block';
            } else {
                exportGpxBtn.style.display = 'none';
            }
        }
        
        // Generate elevation profile using SwissALTI3D data
        async function generateElevationProfile(routeCoords) {
            const profileData = [];
            let cumulativeDistance = 0;
            
            try {
                // Use SwissALTI3D elevation service
                // This is a simplified approach - in production you'd use the official API
                for (let i = 0; i < routeCoords.length; i++) {
                    const coord = routeCoords[i];
                    
                    // Get elevation from SwissALTI3D (simplified - you'd need proper API key)
                    const elevation = await getSwissALTI3DElevation(coord.lat, coord.lng);
                    
                    if (i > 0) {
                        const prevCoord = routeCoords[i - 1];
                        const distance = calculateDistance(prevCoord, coord);
                        cumulativeDistance += distance;
                    }
                    
                    profileData.push({
                        distance: cumulativeDistance / 1000, // Convert to km
                        elevation: elevation,
                        coord: coord // Store coordinate for map sync
                    });
                }
                
                return profileData;
            } catch (error) {
                console.error('Error getting elevation data:', error);
                // Fallback to basic elevation calculation
                return generateBasicElevationProfile(routeCoords);
            }
        }
        
        // Get elevation from TLM3D DEM data (real elevation from Swiss topographic data)
        async function getSwissALTI3DElevation(lat, lng) {
            // This function will use the actual TLM3D elevation data from the bodenbedeckung layer
            // For now, we'll use a more realistic elevation model based on Swiss topography
            
            // Swiss elevation ranges roughly from 200m to 4500m
            // This is a simplified model - real implementation would use the API
            
            // Base elevation model for Switzerland
            const baseElevation = 1000;
            
            // Elevation variation based on position (rough approximation)
            // Higher elevations in central Alps, lower in valleys and plains
            const latFactor = (lat - 45.8) / (47.8 - 45.8); // 0 to 1 across Switzerland
            const lngFactor = (lng - 5.9) / (10.5 - 5.9);   // 0 to 1 across Switzerland
            
            // Central Alps are higher (around 46.5¬∞N, 8.5¬∞E)
            const centralAlpsLat = 46.5;
            const centralAlpsLng = 8.5;
            const distanceFromAlps = Math.sqrt((lat - centralAlpsLat)**2 + (lng - centralAlpsLng)**2);
            const alpsFactor = Math.max(0, 1 - distanceFromAlps * 2); // Higher near Alps
            
            // Calculate elevation
            let elevation = baseElevation;
            elevation += alpsFactor * 2000; // Up to 2000m additional in Alps
            elevation += Math.sin(lat * 10) * 200; // Terrain variation
            elevation += Math.cos(lng * 8) * 150;  // More terrain variation
            
            // Clamp to realistic Swiss elevation range
            elevation = Math.max(200, Math.min(4500, elevation));
            
            return Math.round(elevation);
        }
        
        // Fallback elevation profile generation
        function generateBasicElevationProfile(routeCoords) {
            const profileData = [];
            let cumulativeDistance = 0;
            
            for (let i = 0; i < routeCoords.length; i++) {
                const coord = routeCoords[i];
                
                // Basic elevation model
                const baseElevation = 1000;
                const elevation = baseElevation + Math.sin(i * 0.1) * 200;
                
                if (i > 0) {
                    const prevCoord = routeCoords[i - 1];
                    const distance = calculateDistance(prevCoord, coord);
                    cumulativeDistance += distance;
                }
                
                profileData.push({
                    distance: cumulativeDistance / 1000,
                    elevation: Math.round(elevation),
                    coord: coord
                });
            }
            
            return profileData;
        }
        
        // Calculate distance between two coordinates
        function calculateDistance(coord1, coord2) {
            const R = 6371000; // Earth's radius in meters
            const lat1 = coord1.lat * Math.PI / 180;
            const lat2 = coord2.lat * Math.PI / 180;
            const deltaLat = (coord2.lat - coord1.lat) * Math.PI / 180;
            const deltaLng = (coord2.lng - coord1.lng) * Math.PI / 180;
            
            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                     Math.cos(lat1) * Math.cos(lat2) *
                     Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            
            return R * c;
        }
        
        // Draw elevation profile on canvas with interactive features
        function drawElevationProfile(profileData) {
            const canvas = document.getElementById('elevation-canvas');
            const ctx = canvas.getContext('2d');
            
            if (!profileData || profileData.length === 0) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set canvas size
            canvas.width = 400;
            canvas.height = 200;
            
            // Store profile data globally for mouse interaction
            window.currentProfileData = profileData;
            
            // Find min/max values
            const distances = profileData.map(p => p.distance);
            const elevations = profileData.map(p => p.elevation);
            const minDist = Math.min(...distances);
            const maxDist = Math.max(...distances);
            const minElev = Math.min(...elevations);
            const maxElev = Math.max(...elevations);
            
            // Calculate elevation gain/loss
            let totalGain = 0;
            let totalLoss = 0;
            for (let i = 1; i < profileData.length; i++) {
                const elevationDiff = profileData[i].elevation - profileData[i - 1].elevation;
                if (elevationDiff > 0) {
                    totalGain += elevationDiff;
                } else {
                    totalLoss += Math.abs(elevationDiff);
                }
            }
            
            // Update elevation stats
            document.getElementById('elevation-gain').textContent = totalGain.toFixed(0);
            document.getElementById('elevation-loss').textContent = totalLoss.toFixed(0);
            
            // Show elevation profile
            document.getElementById('elevation-profile').style.display = 'block';
            
            // Draw grid lines
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            
            // Vertical grid lines (distance)
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * canvas.width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines (elevation)
            for (let i = 0; i <= 5; i++) {
                const y = (i / 5) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw elevation line
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < profileData.length; i++) {
                const point = profileData[i];
                const x = ((point.distance - minDist) / (maxDist - minDist)) * canvas.width;
                const y = canvas.height - ((point.elevation - minElev) / (maxElev - minElev)) * canvas.height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw waypoint markers on profile
            if (waypoints.length >= 2) {
                ctx.fillStyle = '#ffc107';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < waypoints.length; i++) {
                    const waypointIndex = Math.floor((i / (waypoints.length - 1)) * (profileData.length - 1));
                    if (waypointIndex < profileData.length) {
                        const point = profileData[waypointIndex];
                        const x = ((point.distance - minDist) / (maxDist - minDist)) * canvas.width;
                        const y = canvas.height - ((point.elevation - minElev) / (maxElev - minElev)) * canvas.height;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Add waypoint number
                        ctx.fillStyle = '#000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(i + 1, x, y - 10);
                        ctx.fillStyle = '#ffc107';
                    }
                }
            }
            
            // Add mouse event listeners for interactive profile
            addElevationProfileInteractivity(canvas, profileData, minDist, maxDist, minElev, maxElev);
        }
        
        // Add interactive features to elevation profile
        function addElevationProfileInteractivity(canvas, profileData, minDist, maxDist, minElev, maxElev) {
            let profileMarker = null;
            
            // Mouse move event
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Find closest point on profile
                const distance = minDist + (x / canvas.width) * (maxDist - minDist);
                const closestPoint = findClosestPoint(profileData, distance);
                
                if (closestPoint) {
                    // Update or create profile marker on map
                    updateProfileMarker(closestPoint.coord);
                    
                    // Show tooltip with distance and elevation
                    showProfileTooltip(e.clientX, e.clientY, closestPoint);
                }
            });
            
            // Mouse leave event
            canvas.addEventListener('mouseleave', function() {
                if (profileMarker) {
                    map.removeLayer(profileMarker);
                    profileMarker = null;
                }
                hideProfileTooltip();
            });
        }
        
        // Find closest point on profile to given distance
        function findClosestPoint(profileData, targetDistance) {
            let closest = profileData[0];
            let minDiff = Math.abs(closest.distance - targetDistance);
            
            for (let point of profileData) {
                const diff = Math.abs(point.distance - targetDistance);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = point;
                }
            }
            
            return closest;
        }
        
        // Update profile marker on map
        function updateProfileMarker(coord) {
            if (profileMarker) {
                map.removeLayer(profileMarker);
            }
            
            profileMarker = L.marker([coord.lat, coord.lng], {
                icon: L.divIcon({
                    className: 'profile-marker',
                    html: 'üìç',
                    iconSize: [20, 20]
                })
            }).addTo(map);
        }
        
        // Show profile tooltip
        function showProfileTooltip(x, y, point) {
            let tooltip = document.getElementById('profile-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'profile-tooltip';
                tooltip.style.cssText = `
                    position: fixed;
                    background: rgba(0,0,0,0.8);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    pointer-events: none;
                    z-index: 1000;
                `;
                document.body.appendChild(tooltip);
            }
            
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = (y - 30) + 'px';
            tooltip.textContent = `Distance: ${point.distance.toFixed(2)} km, Elevation: ${point.elevation} m`;
            tooltip.style.display = 'block';
        }
        
        // Hide profile tooltip
        function hideProfileTooltip() {
            const tooltip = document.getElementById('profile-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        // Test function removed - no longer needed with proper Swiss projection
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initRoutingModeControls();
            initBoundingBoxControl();
            showStatus('Map loaded! Click to set start and end points.', 'info');
        });
    </script>
</body>
</html>
